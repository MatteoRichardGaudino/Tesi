\documentclass[./main.tex]{subfiles}

\begin{document}
\chapter{Implementazione di procedure di decisione per frammenti Binding in Vampire}
L'algoritmo di decisione, la classificazione, Il preprocessing

\section{Preprocessing}

\begin{figure}[H]
    \centering
    \scalebox{0.55}{
        \includesvg{images/4_progettazione/Preprocess.svg}
    }
    \caption{Struttura del Preprocessing}
    \label{fig:preprocessing}
\end{figure}

\subsection{Boolean Top Formula}
\subsection{Forall-And}
\subsection{SAT-Clausification}

\section{Procedura di Decisione}
\begin{figure}[H]
    \centering
    \scalebox{0.55}{
        \includesvg{images/4_progettazione/OneBindingAlgorithm.svg}
    }
    \caption{Struttura dell'algoritmo di decisione}
    \label{fig:algoritmo_decisione}
\end{figure}

\subsection{Implicants Sorting}
\subsection{Maximal Unifiable Subsets}


\begin{algorithm}[H]
    \caption{Maximal Unifiable Subsets}
    \KwSty{Firma:}{ mus($literal$)}\\
    \KwIn{$literal$ un puntatore ad un letterale}
    \KwOut{$\top$ o $\bot$}
    \KwSty{GlobalData: }{ S una mappa da letterali a bool}

\If{$S[literal]$}{
    \Return $\top$\;
}
\If{$literal$ is ground}{
    \Return $groundLiteralMus(literal)$\;
}

$S[literal] = \top$\;
$res := mus(literal, \emptyset)$\;
$S[literal] = \bot$\;
\Return $res$\;
\end{algorithm}


\begin{algorithm}[H]
    \caption{Maximal Unifiable Subsets}
    \KwSty{Firma:}{ mus($literal$, $FtoFree$)}\\
    \KwIn{$literal$ un puntatore ad un letterale, $FtoFree$ un puntatore ad una lista di letterali}
    \KwOut{$\top$ o $\bot$}
    \KwSty{GlobalData: }{ \textbf{S} una mappa da letterali a interi, \textbf{fun} una funzione da lista di letterali a bool, \textbf{tree} un SubstitutionTree}

$isMax := \top$\;
$uIt = tree.getUnifications(query: literal, retrieveSubstitutions: true)$\;
$toFree := \emptyset$\;

\While{$uIt.hasNext()$}{
    $(u, \sigma) := uIt.next()$\;
    \If{$S[u] = 0$}{
        $S[u] = 1$\;

        $l := literal^\sigma$\;
        \If{$l = literal$} {
            $u' := u^\sigma$\;
            \If{$u' = u$}{
                $FtoFree := FtoFree \cup \{u\}$\;
            } \Else{
                $toFree := toFree \cup \{u\}$\;
            }
        }
        \Else{
            $isMax = \bot$\;
            \If{$\neg mus(l, toFree)$}{
                \Return $\bot$\;
            }
            $S[u] = -1$\;
            $toFree := toFree \cup \{u\}$\;
        }
    }
}
\If{$isMax$}{
    \If{$\neg fun(\{x \mid S[x] =1\})$}{
        \Return $\bot$\;
    }
}
\While{$toFree \neq \emptyset$}{
    $S[toFree.pop()] = 0$\;
}
\Return $\top$\;
\end{algorithm}

\begin{algorithm}[H]
    \caption{Maximal Unifiable Subsets Ground}
    \KwSty{Firma:}{ groundMus($literal$)}\\
    \KwIn{$literal$ un puntatore ad un letterale ground}
    \KwOut{$\top$ o $\bot$}
    \KwSty{GlobalData: }{ \textbf{S} una mappa da letterali a interi, \textbf{fun} una funzione da lista di letterali a bool, \textbf{tree} un SubstitutionTree}

\If{$S[literal] \neq 0$}{
    \Return $\top$\;
}
$uIt = tree.getUnifications(query: literal, retrieveSubstitutions: true)$\;
$solution := \emptyset$\;

\While {uIt.hasNext()} {
    $(u, \sigma) := uIt.next()$\;
    \If{$S[u] = 0$} {
        \If{u is ground}{
            $S[u] = -1$\;
        }
        $solution := solution \cup \{u\}$\;
    }
}
\Return $fun(solution)$\;
\end{algorithm}

\subsection{Algoritmo Finale}

\begin{algorithm}[H]
    \caption{Algoritmo di decisione}
    \KwSty{Firma:}{ solve(prp)}\\
    \KwIn{$prp$ il problema pre-processato}
    \KwOut{$\top$ o $\bot$}

$satSolver := newSatSolver()$\;
$satSolver.addClauses(prp.clauses)$\;

\While{$satSolver.solve() = SATISFIABLE$}{
    $res := \top$\;
    $implicants := getImplicants(satSolver, prp)$\;
    $implicants := sortImplicants(implicants)$\;
    \If{implicants contains only ground Literals}{
        \Return $\top$\;
    }

    $agIt := ArityGroupIterator(implicants)$\;
    \While{res And agIt.hasNext()}{
        % $gropu := agIt.next()$\;
        % $tree := buildSubstitutionTree(group)$\;
        % $S := emptyMap: LiteralSet \rightarrow bool$\;
        % "Fill S with 0 foreach literal in group"\;
        
        $maximalUnifiableSubsets := SetupMus(group, internalSat)$\;

        \ForEach{$lit \in group$}{
            \If{$\lnot maximalUnifiableSubsets.mus(lit)$}{
                $res := \bot$\;
                $blockModel(maximalUnifiableSubsets.getSolution())$\;
                \textbf{Break}\;
            }
        }

        \If{$res = \top$}{
            \Return $\top$\;
        }

    }

}
\Return $\bot$\;
\end{algorithm}


\begin{algorithm}[H]
    \caption{Sat interna}
    \KwSty{Firma:}{ internalSat(literals)}\\
    \KwIn{$literals$ una lista di letterali}
    \KwOut{$\top$ o $\bot$}
\If{literals.length = 1 And getSatClauses(literals.top()).length = 1}{
    \Return $\top$\;
}

$satSolver := newSatSolver()$\;
\ForEach{$l \in literals$}{
    $satSolver.addClause(getSatClauses(l))$\;
}

\Return $satSolver.solve() = SATISFIABLE$\;
\end{algorithm}

\begin{algorithm}[H]
    \caption{getImplicants}
    \KwSty{Firma:}{ getImplicants(solver, prp)}\\
    \KwIn{$solver$ un sat solver, $prp$ il problema pre-processato}
    \KwOut{Una lista letterali}

$implicants := \emptyset$\;
\ForEach{$l \in prp.literals()$}{
    $satL := prp.toSat(l)$\;
    \If{$solver.trueInAssignment(satL)$}{
        \If{prp.isBooleanBinding(l)}{
            $implicants := implicants \cup prp.getLiteralBindings(l)$\;
        }
        \Else{
            $implicants := implicants \cup \{l\}$\;
        }
    }
}
\Return $implicants$\;
\end{algorithm}


\section{Algoritmo di Classificazione}

(Input formula rettificata senza true e false)

\begin{figure}[H]
    \centering
    \scalebox{0.55}{
        \includesvg{images/4_progettazione/Classifier.svg}
    }
    \caption{Classificatore}
    \label{fig:classifier}
\end{figure}


\begin{algorithm}
\caption{Classificatore esterno}
\KwSty{Firma:}{ classify($\varphi$)}
\KwIn{$\varphi$ Una formula rettificata}
\KwOut{Un elemento dell'enumerazione Fragment}

\Switch{$\varphi$}{
    \Case{$Literal$}{
        \Return ONE\_BINDING\;
    }
    \Case{$A [\land, \lor] B$}{
        \Return $compare(classify(A), classify(B))$\;
    }
    \Case{$\lnot A$}{
        \Return $classify(A).complementary()$\;
    }
    \Case{$[\forall, \exists]A$}{
        $sub := \varphi$\;
        $connective := \text{connective of } \varphi$\;
        \Repeat{$connective \notin \{\forall, \exists\}$}{
            $sub := \text{subformula of sub}$\;
            $connective := \text{connective of sub}$\;
        }
        $(fragment, \_) := innerClassify(sub)$\;
        \Return $fragment$\;
    }

    \Case{$A \Leftrightarrow B$}{
        \Return $compare(classify(A \Rightarrow B), classify(B \Rightarrow A))$\;
    }
    \Case{$A \oplus B$}{
        \Return $classify(A \Leftrightarrow B).complementary()$\;
    }
    \Case{$A \Rightarrow B$}{
        \Return $compare(classify(\lnot A), classify(B))$\;
    }
}
\end{algorithm}


\begin{algorithm}
    \caption{Classificatore interno}
    \KwSty{Firma:}{ innerClassify($\varphi$)}
    \KwIn{$\varphi$ Una formula rettificata}
    \KwOut{Una coppia (Fragment, Literal)}


\Switch{$\varphi$}{
    \Case{$Literal \; l$}{
        \Return $(ONE\_BINDING, l)$\;
    }
    \Case{$A [\land, \lor] B$}{
        \Return $innerCompare(innerClassify(A), innerClassify(B), \text{connective of } \varphi)$\;
    }
    \Case{$\lnot A$}{
        \Return $innerClassify(A).complementary()$\;
    }
    \Case{$A [\Rightarrow, \Leftrightarrow, \oplus] B$}{
        \Return $innerCompare(innerClassify(A), innerClassify(B), \text{connective of } \varphi)$\;
    }
    \Else{
        \Return $(None, null)$\;
    }
    
}
\end{algorithm}


\begin{algorithm}
    \caption{Compare esterno}
    \KwSty{Firma:}{ compare($A, B$)}
    \KwIn{$A, B$ due elementi dell'enumerazione Fragment}
    \KwOut{Un elemento dell'enumerazione Fragment}
\If{$A = B$}{
    \Return $A$\;
}
\If{$One\_Binding \notin \{A, B\}$}{
    \Return $None$\;
}
\Return $max(A, B)$\;

\end{algorithm}


\begin{algorithm}
    \caption{Compare interno}
    \KwSty{Firma:}{ innerCompare($A, B, con$)}
    \KwIn{$A, B$ due coppie (Fragment, Literal), $con$ un connettivo}
    \KwOut{Una coppia (Fragment, Literal)}



    \Switch{A.first, B.first, con}{
        \Case{One\_Binding, One\_Binding, \_\_}{
            \If{$A.second$ has same terms of $B.second$}{
                \Return $A$\;
            } \ElseIf{$conn = \land$}{
                \Return $(Conjunctive\_Binding, null)$\;
            } \ElseIf{$conn = \lor$}{
                \Return $(Disjunctive\_Binding, null)$\; 
            }
        }

        \Case{[One\_Binding, Conjunctive\_Binding $\mid$ Conjunctive\_Binding, One\_Binding], $\land$}{
            \Return (Conjunctive\_Binding, null)\;
        }
        \Case{[One\_Binding, Disjunctive\_Binding $\mid$ Disjunctive\_Binding, One\_Binding], $\lor$}{
            \Return (Disjunctive\_Binding, null)\;
        }

        \Case{Conjunctive\_Binding, Conjunctive\_Binding, $\land$}{
            \Return (Conjunctive\_Binding, null)\;
        }
        \Case{Disjunctive\_Binding, Disjunctive\_Binding, $\lor$}{
            \Return (Disjunctive\_Binding, null)\;
        }
    }

    \Return $(None, null)$\;
\end{algorithm}


\end{document}

